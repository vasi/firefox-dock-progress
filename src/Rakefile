# Path to xulrunner SDKs. The actual SDKs should be in subdirs
# named after each arch.
ENV['XULRUNNER_SDK_DIR'] ||= ENV['HOME'] + '/Hacking/xulrunner/fx30'

# Path to libraries necessary for xpidl to run (libIDL-2.0.dylib, etc.)
ENV['XPIDL_LIBS'] ||= '/Library/Fink/sl32/lib'


Rake.application.options.threads = `sysctl -n hw.ncpu`.to_i

# Decide what SDKs we want for each arch
def native_arch; @native ||= `arch`.chomp; end
def archsdkid(a); a == 'x86_64' ? '10.6' : '10.4u'; end

# Utilities for arch flags
def archsdk(a)
  i = archsdkid(a)
  if i >= "10.6"
    return `xcodebuild -version -sdk macosx#{i} Path`.strip
  else
    return "/Xcode3/SDKs/MacOSX#{archsdkid(a)}.sdk"
  end
end
def archtarg(a)
  "-mmacosx-version-min=#{archsdkid(a).match(/\d\d\.\d/)[0]}"
end
def archcc(cc, a)
  clang = (cc == 'g++') ? 'clang++' : 'clang'
  compiler = (a == 'x86_64') ? clang : "#{cc}-4.0"
  [compiler, '-arch', a, archtarg(a), '-Wall']
end
# Allow flags to expand to include arch-dependent data
def archxflags(x, a); x.respond_to?(:to_proc) ? x[a] : x; end


# Build something for a particular arch
def compile(target, cc, arch, xflags, strflags)
  sh *(archcc(cc, arch) + archxflags(xflags, arch) + strflags +
    ['-isysroot', archsdk(arch), '-c', '-o', target.name,
      target.prerequisites.first])
end
def xlink(target, cc, arch, xflags, strflags)
  sh *(archcc(cc, arch) + archxflags(xflags, arch) + strflags +
    ["-Wl,-syslibroot,#{archsdk(arch)}", '-o', target.name] +
    target.prerequisites)
end
def lipo(target)
  sh *(%w[lipo -create -output] + [target.name] + target.prerequisites)
end


# Filename-munging: Substitute based on ext; add basename suffix; add arch suf
def subext(s, repl); s.sub(/(\.[^.]*|)$/, repl); end
def sufs(s, suf)
  suf = suf[:suffix] if Hash === suf
  subext(s, (suf || '') + '\1')
end
def sufa(s, arch); subext(s, '-' + arch + '\1'); end

# Build a universal binary
def universal(opts)
  output, input, cflags, ldflags, opt =
    [:output, :input, :cflags, :ldflags, :opt].map { |k| opts[k] || [] }
  single = opts[:arch].size == 1
  
  to_compile = input.grep(/\.(mm|m|c|cc|cpp)$/)
  ccbase = to_compile.grep(/\.(mm|cc|cpp)$/).empty? ? 'gcc' : 'g++'
  link_add = input.grep(/\.(dylib|so)$/)
  compile_add = input - to_compile - link_add
  
  to_lipo = []
  opts[:arch].each do |arch|
    to_link = []
    to_compile.each do |src|
      to_link << sufs(sufa(subext(src, '.o'), arch), opts)
      file to_link.last => ([src] + compile_add) do |t|
        compile(t, ccbase, arch, cflags, opt)
      end
    end
    
    to_lipo << sufs(single ? output : sufa(output, arch), opts)
    file to_lipo.last => (to_link + link_add) do |t|
      xlink(t, ccbase, arch, ldflags, opt)
    end
  end
  file(sufs(output, opts) => to_lipo) { |t| lipo(t) } unless single
  return output
end


# Get a path in the xulrunner sdk
def xsdk(arch, path)
  [ENV['XULRUNNER_SDK_DIR'], arch, path].join('/')
end
def xnative(path); xsdk(native_arch, path); end

# Run xulrunner utils
def xpidl(target, mode)
  sh 'env', "DYLD_FALLBACK_LIBRARY_PATH=#{ENV['XPIDL_LIBS']}",
    xnative('bin/xpidl'), '-I', xnative('idl'),
    '-m', mode,
    '-e', target.name, target.source
end
rule('.xpt' => '.idl') { |t| xpidl(t, 'typelib') }

# Define how to build our binaries
COMMON_CFLAGS = %w[-fno-exceptions -fPIC -fno-strict-aliasing
  -fpascal-strings -fno-common -fshort-wchar]  

def clib(opts)
  universal(opts.merge(
    :output => 'DockProgressC.dylib',
    :input => %w[DockProgressC.m DockProgressC.h],
    :ldflags => COMMON_CFLAGS + %w[-framework Cocoa -dynamiclib
      -install_name @loader_path/../chrome/content/DockProgressC.dylib]))
end


# Define build styles
STYLES = {}
def style(name, xpcom_arch, clib_arch, opts)
  STYLES[name] = {
    :clib => clib(opts.merge(:arch => clib_arch)),
  }
  task name => STYLES[name].values.map { |f| sufs(f, opts) } +
    %w[DockProgress.xpt]
  STYLES[name][:suf] = opts[:suffix]
end
style(:release, %w[ppc i386], %w[ppc i386 x86_64], :opt => %w[-Os])
style(:debug, [native_arch], [native_arch], :opt => %w[-O0 -g],
  :suffix => '-debug')


# Install tasks
def xinstall(src, dst, suf = nil)
  ln sufs(src, suf), File.join(dst, src), :force => true
end
STYLES.each do |n, v|
  task sufs('install', v[:suf]) => n do |t|
    xinstall('DockProgress.xpt', '../components/')
    xinstall(v[:clib], '../chrome/content/', v[:suf])
  end
end


require 'rake/clean'
CLEAN.include('IDockProgress.h', '*.xpt', '*.o', '*.so', '*.dylib')
task :default => :release
